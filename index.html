<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Companion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .tile {
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            font-size: 2rem;
            line-height: 1;
        }
        .tile-gray { background-color: #939B9F; color: white; border-color: #939B9F; }
        .tile-yellow { background-color: #CAB458; color: white; border-color: #CAB458; }
        .tile-green { background-color: #6AAA64; color: white; border-color: #6AAA64; }
        .tile-empty { background-color: white; border-color: #D1D5DB; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto">
        <header class="text-center mb-4">
            <h1 class="text-4xl font-bold tracking-tight">Wordle Companion</h1>
            <p class="text-gray-600 mt-1">Get the optimal next guess!</p>
        </header>

        <!-- Starting Word Selector -->
        <div class="mb-4">
            <label for="starting-word-select" class="block text-sm font-medium text-gray-700 text-center">Select a starting word:</label>
            <select id="starting-word-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-green-500 focus:border-green-500 sm:text-sm rounded-md shadow-sm text-center">
                <option>SALET</option>
                <option>RAISE</option>
                <option>SOARE</option>
                <option>ADIEU</option>
                <option>ROATE</option>
                <option>SLATE</option>
                <option>PLACE</option>
                <option>STARE</option>     
            </select>
        </div>

        <main class="bg-white p-6 rounded-2xl shadow-lg">
            <!-- Optimal Word Display -->
            <div class="text-center">
                <p class="text-sm text-gray-500" id="suggestion-label">Optimal Word to Guess:</p>
                <div id="optimal-word-display" class="text-5xl font-bold tracking-widest my-2 p-4 bg-gray-50 rounded-lg">
                    ...
                </div>
            </div>

            <!-- Feedback Input Grid -->
            <div class="my-6">
                <p class="text-center text-sm text-gray-600 mb-2">Tap the tiles below to set feedback for the word you just guessed.</p>
                <div id="feedback-grid" class="grid grid-cols-5 gap-2">
                    <!-- Tiles will be generated by JavaScript -->
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col gap-3">
                <button id="submit-feedback-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 active:bg-green-800 transition-colors shadow-md" disabled>
                    Submit Feedback & Get Next Word
                </button>
                <button id="reset-btn" class="w-full bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 active:bg-gray-400 transition-colors">
                    Reset Game
                </button>
            </div>

            <!-- Game Status and Results -->
            <div id="status-container" class="mt-6 text-center">
                <p id="status-message" class="text-lg font-semibold text-red-600"></p>
                <p id="possibilities-count" class="text-sm text-gray-500"></p>
                <div id="possible-words-list" class="text-xs text-gray-600 mt-2 max-h-24 overflow-y-auto bg-gray-50 p-2 rounded-md"></div>
            </div>
            
            <!-- Guess History Grid -->
            <div id="history-grid-container" class="grid grid-rows-6 gap-2 my-6">
                <!-- Rows and tiles will be generated by JavaScript -->
            </div>
        </main>
    </div>

    <script>
        
       // --- GLOBAL VARIABLES ---
        let MASTER_WORD_LIST = [];

        // --- DOM ELEMENTS ---
        const optimalWordDisplay = document.getElementById('optimal-word-display');
        const feedbackGrid = document.getElementById('feedback-grid');
        const submitBtn = document.getElementById('submit-feedback-btn');
        const resetBtn = document.getElementById('reset-btn');
        const statusMessage = document.getElementById('status-message');
        const possibilitiesCount = document.getElementById('possibilities-count');
        const possibleWordsList = document.getElementById('possible-words-list');
        const suggestionLabel = document.getElementById('suggestion-label');
        const historyGridContainer = document.getElementById('history-grid-container');
        const startingWordSelect = document.getElementById('starting-word-select');

        // --- GAME STATE ---
        let possibleWords = [];
        let greenPositions = {}; // { position: letter }
        let yellowLetters = new Set(); // Letters known to be in the word
        let greyPositions = {}; // { letter: Set of positions }
        let blackLetters = new Set(); // Letters known NOT to be in the word
        let maxLetterCounts = {}; // { letter: exact_count }
        let attemptNum = 1;
        let currentGuess = "";
        let guessHistory = [];

        // --- CORE LOGIC (Elimination Strategy) ---

        function getFeedback(guess, answer) {
            const guessArray = guess.split('');
            const answerArray = answer.split('');
            const feedback = Array(5).fill('B');
            
            // First pass for Greens
            for (let i = 0; i < 5; i++) {
                if (guessArray[i] === answerArray[i]) {
                    feedback[i] = 'G';
                    answerArray[i] = null; // Mark as used
                }
            }

            // Second pass for Yellows
            for (let i = 0; i < 5; i++) {
                if (feedback[i] !== 'G') {
                    const letterIndex = answerArray.indexOf(guessArray[i]);
                    if (letterIndex !== -1) {
                        feedback[i] = 'Y';
                        answerArray[letterIndex] = null; // Mark as used
                    }
                }
            }
            return feedback.join('');
        }

        function chooseOptimalWord(words) {
            if (!words || words.length === 0) return null;
            if (words.length <= 2) return words[0]; // If only 1 or 2 words left, just guess one

            let bestGuess = null;
            let minWorstCase = Infinity;

            // For performance, we check a smaller subset of candidate words if the list is large
            const candidateGuesses = words.length > 150 ? MASTER_WORD_LIST : words;

            for (const guess of candidateGuesses) {
                const patternMap = new Map();
                for (const answer of words) {
                    const pattern = getFeedback(guess, answer);
                    patternMap.set(pattern, (patternMap.get(pattern) || 0) + 1);
                }
                
                let maxGroupSize = 0;
                for (const count of patternMap.values()) {
                    if (count > maxGroupSize) {
                        maxGroupSize = count;
                    }
                }

                if (maxGroupSize < minWorstCase) {
                    minWorstCase = maxGroupSize;
                    bestGuess = guess;
                }
            }
            
            return bestGuess || words[0];
        }

        // --- UI & GAME FLOW FUNCTIONS ---

        function initializeHistoryGrid() {
            historyGridContainer.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('div');
                row.className = 'grid grid-cols-5 gap-2';
                for (let j = 0; j < 5; j++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile tile-empty w-full aspect-square flex items-center justify-center font-bold rounded-md border-2';
                    row.appendChild(tile);
                }
                historyGridContainer.appendChild(row);
            }
        }

        function updateHistoryGrid() {
            const lastGuessIndex = guessHistory.length - 1;
            if (lastGuessIndex < 0) return;

            const { word, feedback } = guessHistory[lastGuessIndex];
            const historyRow = historyGridContainer.children[lastGuessIndex];

            for (let i = 0; i < word.length; i++) {
                const tile = historyRow.children[i];
                tile.textContent = word[i];
                tile.classList.remove('tile-empty');
                if (feedback[i] === 'G') {
                    tile.classList.add('tile-green');
                } else if (feedback[i] === 'Y') {
                    tile.classList.add('tile-yellow');
                } else {
                    tile.classList.add('tile-gray');
                }
            }
        }

        function renderFeedbackGrid(word) {
            currentGuess = word;
            feedbackGrid.innerHTML = '';
            for (let i = 0; i < word.length; i++) {
                const letter = word[i];
                const tile = document.createElement('div');
                tile.className = 'tile tile-gray w-full aspect-square flex items-center justify-center font-bold rounded-md cursor-pointer border-4';
                tile.textContent = letter;
                tile.dataset.index = i;
                tile.dataset.letter = letter;
                tile.dataset.feedback = 'B'; // B for Black/Gray
                tile.addEventListener('click', () => cycleFeedback(tile));
                feedbackGrid.appendChild(tile);
            }
        }

        function cycleFeedback(tile) {
            const currentFeedback = tile.dataset.feedback;
            let nextFeedback;
            tile.classList.remove('tile-gray', 'tile-green', 'tile-yellow');
            
            if (currentFeedback === 'B') {
                nextFeedback = 'G';
                tile.classList.add('tile-green');
            } else if (currentFeedback === 'G') {
                nextFeedback = 'Y';
                tile.classList.add('tile-yellow');
            } else {
                nextFeedback = 'B';
                tile.classList.add('tile-gray');
            }
            tile.dataset.feedback = nextFeedback;
        }

        function handleSubmitFeedback() {
            const feedback = Array.from(feedbackGrid.children)
                                .map(tile => tile.dataset.feedback)
                                .join('');
            
            guessHistory.push({ word: currentGuess, feedback: feedback });
            updateHistoryGrid();

            if (feedback === 'GGGGG') {
                statusMessage.textContent = "Success!";
                statusMessage.className = "text-lg font-semibold text-green-700";
                submitBtn.disabled = true;
                return;
            }

            // If not a win, show calculating state and proceed
            submitBtn.disabled = true;
            resetBtn.disabled = true;
            suggestionLabel.textContent = "Calculating next best word...";
            optimalWordDisplay.textContent = "...";

            // Allow UI to update before starting heavy calculation
            requestAnimationFrame(() => {
                // --- BUG FIX: New feedback processing logic ---
                const guessLetterCounts = {}; // Tallies feedback for each letter in the guess
                
                // Pass 1: Tally feedback (G, Y, B) for each unique letter in the guess.
                for (let i = 0; i < feedback.length; i++) {
                    const letter = currentGuess[i];
                    const result = feedback[i];
                    if (!guessLetterCounts[letter]) {
                        guessLetterCounts[letter] = { G: 0, Y: 0, B: 0 };
                    }
                    if (result === 'G') guessLetterCounts[letter].G++;
                    else if (result === 'Y') guessLetterCounts[letter].Y++;
                    else guessLetterCounts[letter].B++;
                }

                // Pass 2: Update the global state based on these tallies.
                for (const letter in guessLetterCounts) {
                    const counts = guessLetterCounts[letter];
                    const knownCount = counts.G + counts.Y;

                    if (knownCount > 0) {
                        yellowLetters.add(letter);
                    }

                    // If a black tile was seen, we know the EXACT count of this letter.
                    if (counts.B > 0) {
                        maxLetterCounts[letter] = knownCount;
                    }

                    // If NO green or yellow tiles, it's a true blacklisted letter.
                    if (knownCount === 0) {
                        blackLetters.add(letter);
                    }
                }
                
                // Pass 3: Update positional information (greens and greys).
                for (let i = 0; i < feedback.length; i++) {
                    const result = feedback[i];
                    const letter = currentGuess[i];

                    if (result === 'G') {
                        greenPositions[i] = letter;
                    } else if (result === 'Y' || result === 'B') {
                        // Any non-green position is a "grey" position for that letter.
                        if (!greyPositions[letter]) greyPositions[letter] = new Set();
                        greyPositions[letter].add(i);
                    }
                }

                // --- BUG FIX: Rewritten filtering logic ---
                const newPossibleWords = [];
                for (const word of possibleWords) {
                    let isPossible = true;

                    // Rule 1: Must match all green positions.
                    for (const pos in greenPositions) {
                        if (word[pos] !== greenPositions[pos]) {
                            isPossible = false;
                            break;
                        }
                    }
                    if (!isPossible) continue;

                    // Rule 2: Must not contain any fully blacklisted letters.
                    for (const letter of blackLetters) {
                        if (word.includes(letter)) {
                            isPossible = false;
                            break;
                        }
                    }
                    if (!isPossible) continue;
                    
                    // Rule 3: Must contain all known (yellow/green) letters.
                    const wordLetters = new Set(word);
                    for (const letter of yellowLetters) {
                        if (!wordLetters.has(letter)) {
                            isPossible = false;
                            break;
                        }
                    }
                    if (!isPossible) continue;

                    // Rule 4: Must not have letters in their "grey" positions.
                    for (const letter in greyPositions) {
                        for (const pos of greyPositions[letter]) {
                            if (word[pos] === letter) {
                                isPossible = false;
                                break;
                            }
                        }
                        if (!isPossible) break;
                    }
                    if (!isPossible) continue;

                    // Rule 5: Must have the exact number of letters if the count is known.
                    for (const letter in maxLetterCounts) {
                        const requiredCount = maxLetterCounts[letter];
                        const actualCount = (word.match(new RegExp(letter, "g")) || []).length;
                        if (actualCount !== requiredCount) {
                            isPossible = false;
                            break;
                        }
                    }
                    if (!isPossible) continue;

                    // If all checks pass, keep the word.
                    if (isPossible) {
                        newPossibleWords.push(word);
                    }
                }
                possibleWords = newPossibleWords;
                
                attemptNum++;
                let nextWord;
                if (possibleWords.length === 1) {
                    nextWord = possibleWords[0];
                    suggestionLabel.textContent = "This must be the answer:";
                } else {
                    suggestionLabel.textContent = "Optimal Word to Guess:";
                    nextWord = chooseOptimalWord(possibleWords);
                }
                
                updateUI(nextWord);
                
                // Re-enable buttons
                submitBtn.disabled = false;
                resetBtn.disabled = false;
            });
        }

        function updateUI(nextWord) {
            if (nextWord) {
                optimalWordDisplay.textContent = nextWord;
                renderFeedbackGrid(nextWord);
            } else {
                optimalWordDisplay.textContent = "---";
                statusMessage.textContent = "No possible words match the clues. Please check for errors and reset.";
                statusMessage.className = "text-lg font-semibold text-red-600";
                submitBtn.disabled = true;
            }

            const count = possibleWords.length;
            const plural = count === 1 ? 'possibility' : 'possibilities';
            const verb = count === 1 ? 'remains' : 'remain';
            possibilitiesCount.textContent = `${count} ${plural} ${verb}.`;
            
            if (possibleWords.length < 40 && possibleWords.length > 0) {
                possibleWordsList.textContent = possibleWords.join(', ');
                possibleWordsList.style.display = 'block';
            } else {
                possibleWordsList.style.display = 'none';
            }
        }

        function startGame() {
            if(MASTER_WORD_LIST.length === 0) return; 

            possibleWords = [...MASTER_WORD_LIST];
            guessHistory = [];
            greenPositions = {};
            yellowLetters.clear();
            greyPositions = {};
            blackLetters.clear();
            maxLetterCounts = {};
            attemptNum = 1;
            
            initializeHistoryGrid();

            const firstWord = startingWordSelect.value;
            optimalWordDisplay.textContent = firstWord;
            suggestionLabel.textContent = "Optimal Word to Guess:";
            renderFeedbackGrid(firstWord);

            statusMessage.textContent = "";
            possibilitiesCount.textContent = "";
            possibleWordsList.textContent = "";
            possibleWordsList.style.display = 'none';
            submitBtn.disabled = false;
        }

        async function loadWordsAndStartGame() {
            try {
                const response = await fetch('./words.txt');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                
                MASTER_WORD_LIST = text.split(/\s+/)
                                       .map(word => word.trim().toUpperCase())
                                       .filter(word => word.length === 5);
                
                if (MASTER_WORD_LIST.length === 0) {
                     throw new Error("Word list is empty or could not be processed.");
                }

                startGame();

            } catch (error) {
                console.error("Could not load the word list:", error);
                statusMessage.textContent = "Error: Could not load words.txt. Please make sure the file exists in the repository.";
            }
        }

        // --- EVENT LISTENERS ---
        resetBtn.addEventListener('click', startGame);
        startingWordSelect.addEventListener('change', startGame);
        submitBtn.addEventListener('click', handleSubmitFeedback);

        // --- INITIALIZE GAME ---
        document.addEventListener('DOMContentLoaded', loadWordsAndStartGame);
    </script>
</body>
</html>

