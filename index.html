<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle Companion</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
        }
        .tile {
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out, border-color 0.2s ease-in-out;
            font-size: 2rem;
            line-height: 1;
        }
        .tile-gray { background-color: #939B9F; color: white; border-color: #939B9F; }
        .tile-yellow { background-color: #CAB458; color: white; border-color: #CAB458; }
        .tile-green { background-color: #6AAA64; color: white; border-color: #6AAA64; }
        .tile-empty { background-color: white; border-color: #D1D5DB; }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 flex flex-col items-center min-h-screen p-4">

    <div class="w-full max-w-md mx-auto">
        <header class="text-center mb-4">
            <h1 class="text-4xl font-bold tracking-tight">Wordle Companion</h1>
            <p class="text-gray-600 mt-1">Get the optimal next guess!</p>
        </header>

        <!-- Guess History Grid -->
        <div id="history-grid-container" class="grid grid-rows-6 gap-2 mb-6">
            <!-- Rows and tiles will be generated by JavaScript -->
        </div>

        <main class="bg-white p-6 rounded-2xl shadow-lg">
            <!-- Optimal Word Display -->
            <div class="mb-6 text-center">
                <p class="text-sm text-gray-500" id="suggestion-label">Optimal Word to Guess:</p>
                <div id="optimal-word-display" class="text-5xl font-bold tracking-widest my-2 p-4 bg-gray-50 rounded-lg">
                    ...
                </div>
            </div>

            <!-- Feedback Input Grid -->
            <div class="mb-6">
                <p class="text-center text-sm text-gray-600 mb-2">Tap the tiles below to set feedback for the word you just guessed.</p>
                <div id="feedback-grid" class="grid grid-cols-5 gap-2">
                    <!-- Tiles will be generated by JavaScript -->
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex flex-col gap-3">
                <button id="submit-feedback-btn" class="w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 active:bg-green-800 transition-colors shadow-md" disabled>
                    Submit Feedback & Get Next Word
                </button>
                <button id="reset-btn" class="w-full bg-gray-200 text-gray-700 font-bold py-2 px-4 rounded-lg hover:bg-gray-300 active:bg-gray-400 transition-colors">
                    Reset Game
                </button>
            </div>

            <!-- Game Status and Results -->
            <div id="status-container" class="mt-6 text-center">
                <p id="status-message" class="text-lg font-semibold text-red-600"></p>
                <p id="possibilities-count" class="text-sm text-gray-500"></p>
                <div id="possible-words-list" class="text-xs text-gray-600 mt-2 max-h-24 overflow-y-auto bg-gray-50 p-2 rounded-md"></div>
            </div>
        </main>
    </div>

    <script>
        // --- GLOBAL VARIABLES ---
        let MASTER_WORD_LIST = [];

        // --- DOM ELEMENTS ---
        const optimalWordDisplay = document.getElementById('optimal-word-display');
        const feedbackGrid = document.getElementById('feedback-grid');
        const submitBtn = document.getElementById('submit-feedback-btn');
        const resetBtn = document.getElementById('reset-btn');
        const statusMessage = document.getElementById('status-message');
        const possibilitiesCount = document.getElementById('possibilities-count');
        const possibleWordsList = document.getElementById('possible-words-list');
        const suggestionLabel = document.getElementById('suggestion-label');
        const historyGridContainer = document.getElementById('history-grid-container');

        // --- GAME STATE ---
        let possibleWords = [];
        let includedLetters = new Set();
        let greenPositions = {}; // { position: letter }
        let yellowPositions = {}; // { letter: [wrong positions] }
        let attemptNum = 1;
        let currentGuess = "";
        let guessHistory = [];

        // --- CORE LOGIC (Translated from Python) ---

        function calculatePositionalFrequencies(words) {
            const positionalFreq = Array(5).fill(null).map(() => ({}));
            for (const word of words) {
                for (let i = 0; i < word.length; i++) {
                    const letter = word[i];
                    positionalFreq[i][letter] = (positionalFreq[i][letter] || 0) + 1;
                }
            }
            return positionalFreq;
        }

        function calculateWordScore(word, positionalFrequencies) {
            let score = 0;
            const uniqueLetters = [...new Set(word)];
            for (let i = 0; i < uniqueLetters.length; i++) {
                const letter = uniqueLetters[i];
                const pos = word.indexOf(letter); 
                score += positionalFrequencies[pos][letter] || 0;
            }
            return score;
        }

        function chooseOptimalWord(words) {
            if (!words || words.length === 0) return null;
            const positionalFrequencies = calculatePositionalFrequencies(words);
            let bestWord = null;
            let bestScore = -1;
            for (const word of words) {
                const score = calculateWordScore(word, positionalFrequencies);
                if (score > bestScore) {
                    bestScore = score;
                    bestWord = word;
                }
            }
            return bestWord;
        }

        // --- UI & GAME FLOW FUNCTIONS ---

        function initializeHistoryGrid() {
            historyGridContainer.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const row = document.createElement('div');
                row.className = 'grid grid-cols-5 gap-2';
                for (let j = 0; j < 5; j++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile tile-empty w-full aspect-square flex items-center justify-center font-bold rounded-md border-2';
                    row.appendChild(tile);
                }
                historyGridContainer.appendChild(row);
            }
        }

        function updateHistoryGrid() {
            const lastGuessIndex = guessHistory.length - 1;
            if (lastGuessIndex < 0) return;

            const { word, feedback } = guessHistory[lastGuessIndex];
            const historyRow = historyGridContainer.children[lastGuessIndex];

            for (let i = 0; i < word.length; i++) {
                const tile = historyRow.children[i];
                tile.textContent = word[i];
                tile.classList.remove('tile-empty');
                if (feedback[i] === 'G') {
                    tile.classList.add('tile-green');
                } else if (feedback[i] === 'Y') {
                    tile.classList.add('tile-yellow');
                } else {
                    tile.classList.add('tile-gray');
                }
            }
        }

        function renderFeedbackGrid(word) {
            currentGuess = word;
            feedbackGrid.innerHTML = '';
            for (let i = 0; i < word.length; i++) {
                const letter = word[i];
                const tile = document.createElement('div');
                tile.className = 'tile tile-gray w-full aspect-square flex items-center justify-center font-bold rounded-md cursor-pointer border-4';
                tile.textContent = letter;
                tile.dataset.index = i;
                tile.dataset.letter = letter;
                tile.dataset.feedback = 'B'; // B for Black/Gray
                tile.addEventListener('click', () => cycleFeedback(tile));
                feedbackGrid.appendChild(tile);
            }
        }

        function cycleFeedback(tile) {
            const currentFeedback = tile.dataset.feedback;
            let nextFeedback;
            tile.classList.remove('tile-gray', 'tile-green', 'tile-yellow');
            
            if (currentFeedback === 'B') {
                nextFeedback = 'G';
                tile.classList.add('tile-green');
            } else if (currentFeedback === 'G') {
                nextFeedback = 'Y';
                tile.classList.add('tile-yellow');
            } else {
                nextFeedback = 'B';
                tile.classList.add('tile-gray');
            }
            tile.dataset.feedback = nextFeedback;
        }

        function handleSubmitFeedback() {
            const feedback = Array.from(feedbackGrid.children)
                                .map(tile => tile.dataset.feedback)
                                .join('');
            
            guessHistory.push({ word: currentGuess, feedback: feedback });
            updateHistoryGrid();

            if (feedback === 'GGGGG') {
                statusMessage.textContent = "Congratulations! You solved it!";
                statusMessage.className = "text-lg font-semibold text-green-700";
                submitBtn.disabled = true;
                return;
            }

            for (let i = 0; i < feedback.length; i++) {
                const result = feedback[i];
                const letter = currentGuess[i];

                if (result === 'G') {
                    greenPositions[i] = letter;
                    includedLetters.add(letter);
                } else if (result === 'Y') {
                    includedLetters.add(letter);
                    if (yellowPositions[letter]) {
                        yellowPositions[letter].push(i);
                    } else {
                        yellowPositions[letter] = [i];
                    }
                } else if (result === 'B') {
                    if (!includedLetters.has(letter)) {
                        yellowPositions[letter] = [];
                    }
                }
            }

            let wordsToRemove = new Set();
            for (const word of possibleWords) {
                for (const pos in greenPositions) {
                    if (word[pos] !== greenPositions[pos]) {
                        wordsToRemove.add(word);
                        continue;
                    }
                }
                let wordLetters = new Set(word);
                for (const letter of includedLetters) {
                    if (!wordLetters.has(letter)) {
                        wordsToRemove.add(word);
                        break;
                    }
                }
                if(wordsToRemove.has(word)) continue;

                for (const letter in yellowPositions) {
                    const positions = yellowPositions[letter];
                    if (positions.length === 0) {
                        if (word.includes(letter) && !Object.values(greenPositions).includes(letter)) {
                             wordsToRemove.add(word);
                             continue;
                        }
                    } else {
                        for (const pos of positions) {
                            if (word[pos] === letter) {
                                wordsToRemove.add(word);
                                break;
                            }
                        }
                    }
                }
            }
            
            possibleWords = possibleWords.filter(word => !wordsToRemove.has(word));
            
            attemptNum++;
            let nextWord;
            if (possibleWords.length === 1) {
                nextWord = possibleWords[0];
                suggestionLabel.textContent = "This must be the answer:";
            } else {
                 nextWord = chooseOptimalWord(possibleWords);
            }
            
            updateUI(nextWord);
        }

        function updateUI(nextWord) {
            if (nextWord) {
                optimalWordDisplay.textContent = nextWord;
                renderFeedbackGrid(nextWord);
            } else {
                optimalWordDisplay.textContent = "---";
                statusMessage.textContent = "No possible words match the clues. Please check for errors and reset.";
                statusMessage.className = "text-lg font-semibold text-red-600";
                submitBtn.disabled = true;
            }

            possibilitiesCount.textContent = `${possibleWords.length} possibilities remain.`;
            if (possibleWords.length < 40 && possibleWords.length > 0) {
                possibleWordsList.textContent = possibleWords.join(', ');
                possibleWordsList.style.display = 'block';
            } else {
                possibleWordsList.style.display = 'none';
            }
        }

        function startGame() {
            possibleWords = [...MASTER_WORD_LIST];
            guessHistory = [];
            includedLetters.clear();
            greenPositions = {};
            yellowPositions = {};
            attemptNum = 1;
            
            initializeHistoryGrid();

            const firstWord = "SALET";
            optimalWordDisplay.textContent = firstWord;
            suggestionLabel.textContent = "Optimal Word to Guess:";
            renderFeedbackGrid(firstWord);

            statusMessage.textContent = "";
            possibilitiesCount.textContent = "";
            possibleWordsList.textContent = "";
            possibleWordsList.style.display = 'none';
            submitBtn.disabled = false;
        }

        // --- ASYNC FUNCTION TO LOAD WORDS AND START ---
        async function loadWordsAndStartGame() {
            try {
                // Fetch the file from the current directory on the server
                const response = await fetch('./words.txt');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                
                // Process the text file into an array of words
                MASTER_WORD_LIST = text.split(/\s+/) // Split by any whitespace
                                       .map(word => word.trim().toUpperCase())
                                       .filter(word => word.length === 5);
                
                if (MASTER_WORD_LIST.length === 0) {
                     throw new Error("Word list is empty or could not be processed.");
                }

                // Now that the words are loaded, start the game
                startGame();

            } catch (error) {
                console.error("Could not load the word list:", error);
                statusMessage.textContent = "Error: Could not load words.txt. Please make sure the file exists in the repository.";
            }
        }

        // --- EVENT LISTENERS ---
        resetBtn.addEventListener('click', startGame);
        submitBtn.addEventListener('click', handleSubmitFeedback);

        // --- INITIALIZE GAME ---
        document.addEventListener('DOMContentLoaded', loadWordsAndStartGame);
    </script>
</body>
</html>
